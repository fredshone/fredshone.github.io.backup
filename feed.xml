<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://fredshone.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://fredshone.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-17T13:52:27+00:00</updated><id>https://fredshone.github.io/feed.xml</id><title type="html">&lt;b&gt;Fred Shone&lt;/b&gt;</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Overthinking a Skinny XML Parser with Rust</title><link href="https://fredshone.github.io/blog/2023/skinny-xml-parsing-with-rust/" rel="alternate" type="text/html" title="Overthinking a Skinny XML Parser with Rust"/><published>2023-07-20T14:14:00+00:00</published><updated>2023-07-20T14:14:00+00:00</updated><id>https://fredshone.github.io/blog/2023/skinny-xml-parsing-with-rust</id><content type="html" xml:base="https://fredshone.github.io/blog/2023/skinny-xml-parsing-with-rust/"><![CDATA[<p>Building a fast xml parser for the MATSim network format. Using Rust. Contents roughly as follows:</p> <ul> <li>Problem statement</li> <li>xml format</li> <li>Broad strategy</li> <li>Initial implementation</li> <li>Benchmark</li> <li>Fiddling</li> </ul> <h1 id="problem-statement">Problem statement</h1> <p>I have a big project in mind. For which parsing and holding some big data structures in memory is only a tiny part. But a nice enough place to start.</p> <p>I am going to read a MATSim <em>network</em> file (an xml) and store it (but just the bits i need) in memory. in this case <em>network</em> is referring to transport <em>network</em>, ie roads, rail etc.</p> <p>networks are usefully represented as (directed) graphs, where junctions are vertices/nodes and the links between them edges. But for starters, I’m just going to focus on reading the link lengths only.</p> <p>I want to get these lengths into memory fast. But in the grandiose scheme of things, I want to access access and potentially duplicate the data quickly. So it’s going to be more useful to have (i) a really fast to access data structure, and (ii) minimal memory impact.</p> <hr/> <p><strong>NOTE</strong></p> <p><em>Fast data structure?</em> - I mean that, given a link id, I want to be able to get the length of that link as quickly as possible.</p> <hr/> <h1 id="matsim-xml-format">MATSim XML Format</h1> <p><a href="https://www.matsim.org/">MATSim</a> (Multi Agent Transport Simulation) is a big open source project. The full scope of which is beyond this post. So we just focus in on the MATSim network file format:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;network&gt;</span>

	<span class="nt">&lt;nodes&gt;</span>
		<span class="nt">&lt;node</span> <span class="na">id=</span><span class="s">"nodeA"</span> <span class="na">x=</span><span class="s">"0.0"</span> <span class="na">y=</span><span class="s">"0.0"</span> <span class="nt">&gt;&lt;/node&gt;</span>
		<span class="nt">&lt;node</span> <span class="na">id=</span><span class="s">"nodeB"</span> <span class="na">x=</span><span class="s">"100.0"</span> <span class="na">y=</span><span class="s">"0.0"</span> <span class="nt">&gt;&lt;/node&gt;</span>
	  <span class="c">&lt;!-- and so on... --&gt;</span>
	<span class="nt">&lt;/nodes&gt;</span>

	<span class="nt">&lt;links&gt;</span>
		<span class="nt">&lt;link</span> <span class="na">id=</span><span class="s">"linkE"</span> <span class="na">from=</span><span class="s">"nodeA"</span> <span class="na">to=</span><span class="s">"nodeB"</span> <span class="na">length=</span><span class="s">"100.0"</span> <span class="na">modes=</span><span class="s">"bus,car"</span> <span class="nt">&gt;&lt;/link&gt;</span>
		<span class="nt">&lt;link</span> <span class="na">id=</span><span class="s">"linkW"</span> <span class="na">from=</span><span class="s">"nodeB"</span> <span class="na">to=</span><span class="s">"nodeA"</span> <span class="na">length=</span><span class="s">"102.0"</span> <span class="na">modes=</span><span class="s">"bus,car"</span> <span class="nt">&gt;&lt;/link&gt;</span>
	  <span class="c">&lt;!-- and so on... --&gt;</span>

<span class="nt">&lt;/network&gt;</span>

</code></pre></div></div> <p>Two things to note at this point; (i) nodes (vertices if you’re graph thinking) are defined first, then (ii) links are defined second and contain the desired length attribute.</p> <p>To get us started we’re going to parse into the following structure:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LinkLengths</span> <span class="o">=</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">f32</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>Each link will be identified as by it’s id value (as a String) and the length as an f32 (the Rust primitive 32-bit floating point type).</p> <p>We are going to keep this in a <code class="language-plaintext highlighter-rouge">Links</code> struct so that we can tack on methods and extend in future:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Links</span> <span class="p">{</span>
    <span class="n">lengths</span><span class="p">:</span> <span class="n">LinkLengths</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><strong>NOTE</strong></p> <p>f32 is dumb. Firstly we probably don’t want negative numbers, they do not make sense for a road network. Secondly f32 is unnecessarily large. So we might revisit this later.</p> <hr/> <h1 id="broad-strategy">Broad Strategy</h1> <p>Firstly I’m just going to get it running. The excellent <a href="https://github.com/tafia/quick-xml">quick_xml</a> is going to spin through the xml and we’re going to populate our <code class="language-plaintext highlighter-rouge">LinkLengths</code>.</p> <p>Then we’re going to test and establish some benchmarks for:</p> <ul> <li>parsing the xml (fast is good but this isn’t really a top priority)</li> <li>read time (we’re going to ask for the length of a bunch of links)</li> </ul> <p>Then we’re going to try out a few obvious improvements:</p> <ul> <li>stress about using String and or clone</li> <li>squeeze the data types</li> <li>completely reimagine how we are going to be able to use the data (ie reindex and use an array)</li> </ul> <h1 id="initial-implementation">Initial Implementation</h1> <h2 id="reader">Reader</h2> <p>First I set up a helper funcion to set up the <a href="https://docs.rs/quick-xml/latest/quick_xml/index.html">quick_xml reader</a>. I engage in some <code class="language-plaintext highlighter-rouge">Box</code> shenanigans because the full version also accepts a decoding BufReader for zipped files.</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">XMLReader</span> <span class="o">=</span> <span class="nn">quick_xml</span><span class="p">::</span><span class="n">Reader</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BufRead</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">XMLReader</span><span class="p">,</span> <span class="n">XMLReaderError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">)</span><span class="nf">.context</span><span class="p">(</span><span class="s">"Could not open file"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">xml_reader</span> <span class="o">=</span> <span class="nn">quick_xml</span><span class="p">::</span><span class="nn">Reader</span><span class="p">::</span><span class="nf">from_reader</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
    <span class="n">xml_reader</span><span class="nf">.check_comments</span><span class="p">(</span><span class="k">false</span><span class="p">)</span><span class="nf">.check_end_names</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">xml_reader</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><strong>NOTE</strong></p> <p>The quick_xml docs say we can disable checking in various places and go faster. This is only sensible if we trust the ingested xml, which I choose to do for now.</p> <hr/> <p><strong>NOTE</strong></p> <p>Also note that I’ve been careful/pedantic/naive and created some custom errors using <code class="language-plaintext highlighter-rouge">thiserror</code>. I’m not including any explanation of these. If you’re interested in exact the final implementation then LINK INCOMING.</p> <hr/> <h2 id="parsing-xml">Parsing XML</h2> <p>The <code class="language-plaintext highlighter-rouge">XMLReader</code> we have created is just a fancy quick_xml <code class="language-plaintext highlighter-rouge">Reader</code> struct. This is used to loop through the xml contents returning them in order as different quick_xml::events::Event enum variations. We can then run a match statement on these events and do something with them depending on thier contents. The general pattern is:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">reader</span> <span class="o">=</span> <span class="nf">from_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">)</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">loop</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">reader</span><span class="nf">.read_event_into</span><span class="p">(</span><span class="o">&amp;</span> <span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
    <span class="nn">Event</span><span class="p">::</span><span class="nf">Start</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">event</span><span class="p">),</span>
    <span class="nn">Event</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{},</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are various different Events that make up what I generally think of as xml elements. We are going to ignore everything apart from <code class="language-plaintext highlighter-rouge">Event::Start</code> which will hold the information we need for our link lengths map (eg <code class="language-plaintext highlighter-rouge">&lt;link id="linkE" from="nodeA" to="nodeB" length="100.0" modes="bus,car" &gt;</code>), and <code class="language-plaintext highlighter-rouge">Event::Eof</code> which we use to identify the end of the file so we can break the loop.</p> <hr/> <p><strong>NOTE</strong></p> <p>quick_xml is reading our data into the <code class="language-plaintext highlighter-rouge">buffer</code> and generally doing as best as it can to avoid allocating memory. The oportunity for us is to then do the absolute minimum with this buffer data, only using what we need.</p> <hr/> <p><code class="language-plaintext highlighter-rouge">Event::Start</code> holds a <code class="language-plaintext highlighter-rouge">StartEvent</code> struct which has a <code class="language-plaintext highlighter-rouge">name</code> field. This is essentially just a view into the buffer, but we can use it to look for elements named “link” and then do something with it:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">loop</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">reader</span><span class="nf">.read_event_into</span><span class="p">(</span><span class="o">&amp;</span> <span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
    <span class="nn">Event</span><span class="p">::</span><span class="nf">Start</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="k">if</span> <span class="n">event</span><span class="nf">.name</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span> <span class="o">==</span> <span class="s">b"link"</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="nf">do_something</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nn">Event</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{},</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="parsing-xml-attributes">Parsing XML Attributes</h2> <p>So now <code class="language-plaintext highlighter-rouge">do_something</code> is only going to be called on link elements. These elements contain the xml attributes, why quick_xml exposes as <code class="language-plaintext highlighter-rouge">Attributes</code> via <code class="language-plaintext highlighter-rouge">event.attributes()</code>:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">loop</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">reader</span><span class="nf">.read_event_into</span><span class="p">(</span><span class="o">&amp;</span> <span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
    <span class="nn">Event</span><span class="p">::</span><span class="nf">Start</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="k">if</span> <span class="n">event</span><span class="nf">.name</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span> <span class="o">==</span> <span class="s">b"link"</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">event</span><span class="nf">.attributes</span><span class="p">();</span>
      <span class="nf">do_something</span><span class="p">(</span><span class="n">attributes</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nn">Event</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{},</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">Attributes</code> can be iterated though as individual <code class="language-plaintext highlighter-rouge">Attribute</code> structs. These contain a key and value field. We can now look at these keys, to identify the ones we need (<code class="language-plaintext highlighter-rouge">id</code> and <code class="language-plaintext highlighter-rouge">length</code>).</p> <hr/> <p><strong>NOTE</strong></p> <p>Reminder that <code class="language-plaintext highlighter-rouge">Attributes</code> and <code class="language-plaintext highlighter-rouge">Attribute</code> still contain fields that are slices of our buffer. quick_xml is “simply” making sure we look at the right bits.</p> <hr/> <p>I’m confident that <code class="language-plaintext highlighter-rouge">id</code> is always going to be the first attribute, so we can create a String called id as follows:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">loop</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">reader</span><span class="nf">.read_event_into</span><span class="p">(</span><span class="o">&amp;</span> <span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
    <span class="nn">Event</span><span class="p">::</span><span class="nf">Start</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="k">if</span> <span class="n">event</span><span class="nf">.name</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span> <span class="o">==</span> <span class="s">b"link"</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">event</span><span class="nf">.attributes</span><span class="p">();</span>
      <span class="c1">// some wizardry to create an iterator</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">iter_attributes</span> <span class="o">=</span> <span class="n">attributes</span><span class="nf">.with_checks</span><span class="p">(</span><span class="k">false</span><span class="p">)</span><span class="nf">.flatten</span><span class="p">();</span>

      <span class="c1">// get id (we "know" it will be first)</span>
      <span class="k">let</span> <span class="n">id_attribute</span> <span class="o">=</span> <span class="n">iter_attributes</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">LinkParserError</span><span class="p">::</span><span class="nf">LinkIdReadFailure</span><span class="p">())</span><span class="o">?</span><span class="py">.value</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="n">id_att</span><span class="nf">.to_owned</span><span class="p">())</span><span class="o">?</span><span class="p">;</span>

      <span class="nf">do_something</span><span class="p">(</span><span class="n">attributes</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nn">Event</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{},</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">String::from_utf8</code> is creating a String struct from the buffer. Up until now we avoided any new allocations beyond the buffer.</p> <p>I’m less confident on the consistency of the location of the <code class="language-plaintext highlighter-rouge">length</code> attribute. If I was I would use something like <code class="language-plaintext highlighter-rouge">iter_attributes.take(3).next()</code>. Instead we are going to use <code class="language-plaintext highlighter-rouge">find_map</code>. This will take a function that should return <code class="language-plaintext highlighter-rouge">Some(f32)</code> in the event of a <code class="language-plaintext highlighter-rouge">length</code> attribute and otherwise <code class="language-plaintext highlighter-rouge">None</code>:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">parse_length</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Attribute</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">a</span><span class="py">.key</span><span class="nf">.into_inner</span><span class="p">()</span> <span class="p">{</span>
        <span class="s">b"length"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">str</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="py">.value</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">string</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div> <p>We use this in our loop to get the <code class="language-plaintext highlighter-rouge">length</code> value:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">loop</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">reader</span><span class="nf">.read_event_into</span><span class="p">(</span><span class="o">&amp;</span> <span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
    <span class="nn">Event</span><span class="p">::</span><span class="nf">Start</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="k">if</span> <span class="n">event</span><span class="nf">.name</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span> <span class="o">==</span> <span class="s">b"link"</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">event</span><span class="nf">.attributes</span><span class="p">();</span>
      <span class="c1">// some wizardry to create an iterator</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">iter_attributes</span> <span class="o">=</span> <span class="n">attributes</span><span class="nf">.with_checks</span><span class="p">(</span><span class="k">false</span><span class="p">)</span><span class="nf">.flatten</span><span class="p">();</span>

      <span class="c1">// get id (we "know" it will be first)</span>
      <span class="k">let</span> <span class="n">id_attribute</span> <span class="o">=</span> <span class="n">iter_attributes</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">LinkParserError</span><span class="p">::</span><span class="nf">LinkIdReadFailure</span><span class="p">())</span><span class="o">?</span><span class="py">.value</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="n">id_att</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

      <span class="c1">// get length (this could be anywhere later)</span>
      <span class="k">let</span> <span class="n">length</span> <span class="o">=</span> <span class="n">attributes</span><span class="nf">.find_map</span><span class="p">(</span> <span class="k">Self</span><span class="p">::</span><span class="n">parse_length</span> <span class="p">)</span>
      <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">LinkParserError</span><span class="p">::</span><span class="nf">FindLengthError</span><span class="p">())</span><span class="o">??</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nn">Event</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{},</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><strong>NOTE</strong></p> <p>On handling errors: <code class="language-plaintext highlighter-rouge">parse_length()</code> uses <code class="language-plaintext highlighter-rouge">unwrap()</code> twice, panicking if either it can’t convert to <code class="language-plaintext highlighter-rouge">str</code> or parse that as a float.</p> <p>The fancier version propagates these errors up by returning a LinkParser error. This results in an awkward looking return type; <code class="language-plaintext highlighter-rouge">Option&lt;Result&lt;f32, LinkParserError&gt;&gt;</code> - ie an <code class="language-plaintext highlighter-rouge">Option</code> of a <code class="language-plaintext highlighter-rouge">Result</code>.</p> <p>In this case <code class="language-plaintext highlighter-rouge">None</code> means that the given <code class="language-plaintext highlighter-rouge">Attribute</code> was not a link length. No problem - we keep iterating.</p> <p><code class="language-plaintext highlighter-rouge">Some&lt;LinkParserError&gt;</code> means that it found the link length attribute key but failed to parse the value into a float.</p> <p><code class="language-plaintext highlighter-rouge">Some&lt;Ok&lt;f32&gt;&gt;</code> is what we are after but we then have to unpack all this.</p> <p>There is then the case where we only returned <code class="language-plaintext highlighter-rouge">None</code> - ie we failed to find the length attribute - in which case we <code class="language-plaintext highlighter-rouge">find_map</code> returns <code class="language-plaintext highlighter-rouge">None</code> and we raise a new error <code class="language-plaintext highlighter-rouge">FindLengthError</code>.</p> <p>This was certainly all overkill.</p> <hr/> <h2 id="finally">Finally</h2> <p>So now we have a way of getting <code class="language-plaintext highlighter-rouge">id</code> and <code class="language-plaintext highlighter-rouge">length</code> for each link we can put this logic in a constructor method for our <code class="language-plaintext highlighter-rouge">Links</code> struct. I simply add an empty hashmap (the <code class="language-plaintext highlighter-rouge">LinkLengths</code> type), populate this with <code class="language-plaintext highlighter-rouge">id</code> and <code class="language-plaintext highlighter-rouge">length</code>. Then return a populated <code class="language-plaintext highlighter-rouge">Links</code> struct:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Links</span> <span class="p">{</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_reader</span><span class="p">(</span><span class="k">mut</span> <span class="n">reader</span><span class="p">:</span> <span class="n">XMLReader</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="n">LinkParserError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lengths</span> <span class="o">=</span> <span class="nn">LinkLengths</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// omited logic used to get id and length</span>
            <span class="c1">// add to hashmap</span>
            <span class="n">lengths</span><span class="nf">.insert</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">Links</span> <span class="p">{</span>
            <span class="n">lengths</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Then some tests:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span><span class="p">;</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_test_network_xml</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">PathBuf</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">env!</span><span class="p">(</span><span class="s">"CARGO_MANIFEST_DIR"</span><span class="p">));</span>
        <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="s">"fixtures/network_test.xml"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">links</span> <span class="o">=</span> <span class="nn">Links</span><span class="p">::</span><span class="nf">from_xml</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">links</span><span class="py">.lengths</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">links</span><span class="py">.lengths</span><span class="nf">.get</span><span class="p">(</span><span class="s">"linkE"</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mf">100.5</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">links</span><span class="py">.lengths</span><span class="nf">.get</span><span class="p">(</span><span class="s">"linkW"</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mf">102.0</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/work-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/work-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/work-1400.webp"/> <img src="/assets/img/work.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> <a href="https://xkcd.com/1741">xkcd</a> </div> <h1 id="benchmarking">Benchmarking</h1> <p>Reminder that I want to build two types of benchmark:</p> <ul> <li>how fast can we parse the xml</li> <li>how fast can we access link lengths from our <code class="language-plaintext highlighter-rouge">Links</code> struct</li> </ul> <p>I’m using <code class="language-plaintext highlighter-rouge">criterion</code> for benchmarking. I am not going to go into details (criterion has a good getting started) just focus on broad sweeps.</p> <h2 id="parsing-xml-1">Parsing XML</h2> <p>Easy peasy, I bosh a big example xml in memory. I am slightly concerned that using too small a dataset will make measuring improvemnts hard because there will be some fixed io cost that will dominate tiny examples. So I end up using an 8MB MATSim network from central London.</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_link_lengths</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Criterion</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="nf">.bench_function</span><span class="p">(</span><span class="s">"build link lengths from xml"</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">PathBuf</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">env!</span><span class="p">(</span><span class="s">"CARGO_MANIFEST_DIR"</span><span class="p">));</span>
            <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="s">"fixtures/network_big.xml"</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">links</span> <span class="o">=</span> <span class="nn">Links</span><span class="p">::</span><span class="nf">from_xml</span><span class="p">(</span><span class="nf">black_box</span><span class="p">(</span><span class="n">path</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">})</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>We can load this network in ~30ms.</p> <h2 id="accessing">Accessing</h2> <p>This is basically just calling <code class="language-plaintext highlighter-rouge">get(&amp;key)</code> on <code class="language-plaintext highlighter-rouge">LinkLengths</code> which is a hashmap. I use the same network for this test but keep it’s creation outside the benchmarker. I stress a little about having a systematic and consistent way of creating link keys:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">access_link_lengths</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Criterion</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">PathBuf</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">env!</span><span class="p">(</span><span class="s">"CARGO_MANIFEST_DIR"</span><span class="p">));</span>
    <span class="n">path</span><span class="nf">.push</span><span class="p">(</span><span class="s">"fixtures/network_big.xml"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">links</span> <span class="o">=</span> <span class="nn">Links</span><span class="p">::</span><span class="nf">from_xml</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nn">StdRng</span><span class="p">::</span><span class="nf">seed_from_u64</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">link_keys</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">links</span><span class="py">.lengths</span><span class="nf">.len</span><span class="p">())</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="n">link_keys</span><span class="nf">.sort</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nf">black_box</span><span class="p">(</span><span class="n">link_keys</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.choose_multiple</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">rng</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>

    <span class="n">c</span><span class="nf">.bench_function</span><span class="p">(</span><span class="s">"query link lengths"</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">lid</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">samples</span> <span class="p">{</span>
                <span class="n">links</span><span class="nf">.get</span><span class="p">(</span><span class="o">**</span><span class="n">lid</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>We can access each length in about 3µs.</p> <h1 id="fiddling">Fiddling</h1> <h2 id="quick_xml-checks">Quick_xml Checks</h2> <p>Disabling the quick_xml checks (<code class="language-plaintext highlighter-rouge">let mut iter_attributes = attributes.with_checks(false).flatten();</code>) turns out to save us 5% loading time - which seems well worth any risk. So we keep the checks removed.</p> <h2 id="precision">Precision</h2> <p>f32 is probably overkill. We can reasonably expect links to be between several meters and several kms long. We can also expect them to always be positive. We also might not care much about decimal places. So I check the impact of switching to u16 (unsigned integer with maximum around 65k).</p> <p>No change to our benchmarks. This is expected. We actually have to still parse the xml lengths as floats before converting them to integers (maybe we could to something better).</p> <p>We do know that we have halved the link lengths memory requirement (at least in theory) and can get faster subsequent operations with integers. But it is at the expense of precision, which might cause problems later on. For example I know we will need to calculate duration on a link for a given speed. This will inneviatbly be a float operation and for short links, precision will matter.</p> <p>So we could try f16 from <a href="https://docs.rs/half/latest/half/index.html">half</a>. But reading the docs I see that we can only guarantee memory improvements, as not all hardware will support f16 operations. But we’ve come this far and so i set up a new benchmarks that extracts the link lengths and then makes some arbitrary operations. This turns out to be about 5% slower using half::f16, presumably as it adds a bunch of conversions on my hardware.</p> <p>So to summarise, f32 seems fine for now. If it turns out that precision doesn’t matter as much but memory does. Then there are some easy memory wins, but they might come at the expense of inprecise or slower ops.</p> <h2 id="strings">Strings</h2> <p>We need to create some data in memory for each key (the fast_xml buffer from which we parse the key is transient). Using <code class="language-plaintext highlighter-rouge">String</code> is not great. We immediately have to allocate to heap and we get some functionality (<code class="language-plaintext highlighter-rouge">.push()</code>) that we don’t need - our keys can be immutable.</p> <p><a href="https://docs.rs/compact_str/0.1.0/compact_str/struct.CompactStr.html">compact_str</a> has <em>“an immutable a memory efficient immuatable string that can be used almost anywhere a String or &amp;str can be used”.</em> Sounds good but seems to cause a 5% regression for our hashmap accessing benchmark. Not really sure why but I’m expecting to hit the hashmap a lot so no good.</p> <h2 id="btreemap">BTreeMap</h2> <p>Replacing the HashMap with a BTreeMap very bad idea. Writting is 5% slower. Access 300% slower.</p> <h2 id="complete-reindex">Complete reindex</h2> <p>I already know that I am going to be looking up link lengths (and other values) a lot. The fastest way to do this would be to dump the length values into an array and use a <code class="language-plaintext highlighter-rouge">usize</code> key to directly access the array.</p> <p>To be actually useful I add an <code class="language-plaintext highlighter-rouge">Indexer</code>, which provides methods to (i) consistently map keys into <code class="language-plaintext highlighter-rouge">usize</code> (the same key should always return the same <code class="language-plaintext highlighter-rouge">usize</code>), and (ii) I need to be able to retrieve my keys again using the new <code class="language-plaintext highlighter-rouge">usize</code>:</p> <div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Indexer</span> <span class="p">{</span>
    <span class="n">key_to_index</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index_to_key</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Indexer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nn">Indexer</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">index</span> <span class="o">=</span> <span class="k">self</span><span class="py">.index_to_key</span><span class="nf">.len</span><span class="p">();</span>
        <span class="c1">// todo - remove clone</span>
        <span class="k">self</span><span class="py">.key_to_index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">index</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.index_to_key</span><span class="nf">.push</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// todo - has a clone - prefer to return a ref</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.index_to_key</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span>
        <span class="p">}</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.index_to_key</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>At xml read time this builds a map of keys to <code class="language-plaintext highlighter-rouge">usize</code> plus puts a clone of the keys in a vec so they can be retrieved using the index. This is a little more work and about double the memory, but only causes a 5% regression on xml read time. We can probably engineer out the clone and fuss around with the String size in future.</p> <p>Accessing link lengths using the new <code class="language-plaintext highlighter-rouge">usize</code> is obviously a lot faster (~95% faster), we no longer have to worry about the hash, instead we immediately fetch with the vec index. Provided we are going to be doing more a lot more accessing versus creating then this is a no-brainer.</p> <hr/> <p><strong>NOTE</strong></p> <p>WIP ___</p>]]></content><author><name></name></author><category term="MATSim"/><category term="Rust"/><category term="parsing"/><category term="xml"/><summary type="html"><![CDATA[a Rust parser for MATSim network format]]></summary></entry></feed>